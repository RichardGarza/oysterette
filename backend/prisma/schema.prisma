// Oysterette App - Prisma Schema
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User Model
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String
  password  String   // hashed with bcrypt

  // User preferences stored as JSON
  preferences Json?    @default("{}")

  // Reviewer credibility metrics
  credibilityScore  Float   @default(1.0)  // Multiplier for review influence (0.5 to 1.5)
  totalAgrees       Int     @default(0)    // Total "Agree" votes received
  totalDisagrees    Int     @default(0)    // Total "Disagree" votes received
  reviewCount       Int     @default(0)    // Total reviews written

  // Relations
  reviews        Review[]
  topOysters     UserTopOyster[]
  votesGiven     ReviewVote[]   @relation("VoterVotes")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

// Oyster Model
model Oyster {
  id             String   @id @default(uuid())
  name           String   @unique
  species        String
  origin         String   // e.g., "Deep Bay"
  standoutNotes  String?  // e.g., "Favorite, dense flavorful"

  // 10-point scale attributes (seed data / baseline)
  size           Int      @default(5)  // 1 (Tiny) to 10 (Huge)
  body           Int      @default(5)  // 1 (Thin) to 10 (Extremely Fat)
  sweetBrininess Int      @default(5)  // 1 (Very Sweet) to 10 (Very Salty)
  flavorfulness  Int      @default(5)  // 1 (Boring) to 10 (Extremely Bold)
  creaminess     Int      @default(5)  // 1 (None) to 10 (Nothing But Cream)

  // Aggregated rating data (calculated from user reviews)
  totalReviews    Int     @default(0)   // Total number of user reviews
  avgRating       Float   @default(0)   // Average rating (LOVED_IT=4, LIKED_IT=3, MEH=2, HATED_IT=1)

  // Aggregated attribute scores (weighted average of seed + user data)
  avgSize           Float?  // Calculated average size rating
  avgBody           Float?  // Calculated average body rating
  avgSweetBrininess Float?  // Calculated average sweet/brininess rating
  avgFlavorfulness  Float?  // Calculated average flavorfulness rating
  avgCreaminess     Float?  // Calculated average creaminess rating

  // Overall weighted score (0-10 scale)
  overallScore    Float   @default(5)   // Weighted combination of all factors

  // Relations
  reviews        Review[]
  topOysterUsers UserTopOyster[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("oysters")
}

// Review Model
model Review {
  id       String       @id @default(uuid())

  // Relations
  userId   String
  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  oysterId String
  oyster   Oyster       @relation(fields: [oysterId], references: [id], onDelete: Cascade)

  // Rating: Loved It, Liked It, Meh, Hated It
  rating   ReviewRating

  // 10-point scale sliders
  size           Int?     // User's rating 1-10
  body           Int?
  sweetBrininess Int?
  flavorfulness  Int?
  creaminess     Int?

  // Personal notes
  notes    String?

  // Community voting metrics
  agreeCount     Int      @default(0)    // Total "Agree" votes
  disagreeCount  Int      @default(0)    // Total "Disagree" votes
  netVoteScore   Float    @default(0)    // Weighted: agrees(+1.0) + disagrees(-0.6)
  weightedScore  Float    @default(1.0)  // Final weight multiplier for this review (0.4 to 1.5)

  // Relations
  votes    ReviewVote[]

  createdAt DateTime @default(now())

  @@unique([userId, oysterId])  // One review per user per oyster
  @@map("reviews")
}

// User's Top Oysters (Many-to-Many relationship)
model UserTopOyster {
  id       String @id @default(uuid())

  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  oysterId String
  oyster   Oyster @relation(fields: [oysterId], references: [id], onDelete: Cascade)

  rank     Int    // Order in user's top list (1, 2, 3, etc.)

  addedAt  DateTime @default(now())

  @@unique([userId, oysterId])
  @@map("user_top_oysters")
}

// Review Vote Model (Agree/Disagree on reviews)
model ReviewVote {
  id       String   @id @default(uuid())

  // Relations
  userId   String
  voter    User     @relation("VoterVotes", fields: [userId], references: [id], onDelete: Cascade)

  reviewId String
  review   Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  // Vote type: true = Agree, false = Disagree
  isAgree  Boolean

  createdAt DateTime @default(now())

  @@unique([userId, reviewId])  // One vote per user per review
  @@map("review_votes")
}

// Enum for Review Ratings
enum ReviewRating {
  LOVED_IT
  LIKED_IT
  MEH
  HATED_IT
}
